# Caching AI planning & locate

Midscene supports caching Plan steps and matched DOM element information to reduce AI model calls and greatly improve execution efficiency.

Android/iOS automation tasks support planning cache but not element location cache (due to lack of XPath support).

**Effect**

With caching enabled, test execution time is significantly reduced. For example, in the following case, execution time was reduced from 51 seconds to 28 seconds.

* **before**

![](/cache/no-cache-time.png)

* **after**

![](/cache/use-cache-time.png)

## Cache strategies

### Disable cache

Configuration: `cache: false` or not configuring the `cache` option

Completely disable cache functionality, always call AI model for every operation. Suitable when you need real-time results or for debugging. By default, if you don't configure the `cache` option, caching is disabled.

```javascript
// Direct Agent creation
const agent = new PuppeteerAgent(page, {
  cache: false
});

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);

// YAML configuration
// agent:
//   cache: false
```

### Read-write mode

Configuration: `cache: { id: "my-cache-id" }`

Automatically read existing cache and update cache files during execution. Additionally, the following two scenarios support configuring `cache: true` to auto-generate cache ID:
- Playwright AI Fixture automatically generates cache ID from test information
- YAML mode automatically uses filename as cache ID

```javascript
// Direct Agent creation - explicit cache ID
const agent = new PuppeteerAgent(page, {
  cache: { id: "my-cache-id" }
});

// Playwright AI Fixture - auto-generate cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true  // Auto-generate cache ID from test case name
  }),
);

// Playwright AI Fixture - explicit cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// YAML configuration - explicit cache ID
agent:
  cache:
    id: "my-cache-test"

// YAML configuration - auto-generate cache ID
agent:
  cache: true

```

### Read-only, manual write

Configuration: `cache: { strategy: "read-only", id: "my-cache-id" }`

Only read cache, no automatic writing to cache files. Requires manual `agent.flushCache()` call to write cache files. Suitable for production environments to ensure cache consistency.

```javascript
// Direct Agent creation
const agent = new PuppeteerAgent(page, {
  cache: { strategy: "read-only", id: "my-cache-id" }
});

// Manual cache write required
await agent.flushCache();

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only", id: "readonly-cache" }
  }),
);

// YAML configuration
agent:
  cache:
    id: "my-cache-test"
    strategy: "read-only"
```

### Compatibility mode (not recommended)

Configuration via `MIDSCENE_CACHE=1` environment variable with cacheId, equivalent to read-write mode.

```javascript
// Old way, requires MIDSCENE_CACHE=1 environment variable and cacheId
const agent = new PuppeteerAgent(originPage, {
  cacheId: 'puppeteer-swag-sab'
});
```

```bash
MIDSCENE_CACHE=1 tsx demo.ts
```

## In Playwright test scenarios

Using Midscene Playwright AI Fixture, Midscene will automatically generate cacheId and enable read-write cache by default.

```javascript
// Simplest configuration: auto-generate cache ID, enable read-write cache
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true
  }),
);

test('my test case', async ({ ai, aiAction, agentForPage }) => {
  // Use fixture-provided AI methods, cache configuration is automatically applied
  await aiAction('click the button');

  // Or get agent instance
  const agent = await agentForPage();
  await agent.aiAction('click the button');
});
```

You can also configure manually:

```javascript
// Explicit cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// Read-only cache, suitable for production
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only", id: "readonly-cache" }
  }),
);

// Disable cache
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);
```

## In command line tools and YAML files

Set cache options in `agent.cache` in the YAML file:

```yaml
# Read-write cache - auto-use filename as cache ID
target:
  url: https://example.com/
  viewportWidth: 800
  viewportHeight: 600

agent:
  cache: true

tasks:
  - name: "Test cache functionality"
    flow:
      - aiAction: "click the title"
```

```yaml
# Read-write cache - explicit cache ID
agent:
  cache:
    id: "my-cache-test"
```

```yaml
# Read-only cache - read cache only, requires manual write
agent:
  cache:
    id: "my-cache-test"
    strategy: "read-only"
```

```yaml
# Disable caching
agent:
  cache: false
```

## In direct Agent creation scenarios

When creating Agent instances directly (such as PuppeteerAgent, PlaywrightAgent, iosAgent, androidAgent, etc.), you need to explicitly set cache configuration:

```javascript
// Read-write cache - automatically read and write cache
const agent = new PuppeteerAgent(originPage, {
  cache: { id: 'puppeteer-swag-sab' }
});

// Playwright Agent also supports this
const agent = new PlaywrightAgent(page, {
  cache: { id: 'playwright-login-test' }
});

// Read-only cache - read cache only, requires manual write
const agent = new PuppeteerAgent(originPage, {
  cache: { strategy: "read-only", id: 'puppeteer-swag-sab' }
});

// Manual cache write (read-only strategy only)
await agent.flushCache();

// Disable caching
const agent = new PuppeteerAgent(originPage, {
  cache: false
});
```

## Cache files and storage

Cache contents will be saved in the `./midscene_run/cache` directory with the `.cache.yaml` as the extension name.

These two types of content will be cached:

1. the result of planning, like calls to `.ai` `.aiAction`
2. The XPaths for elements located by AI, such as `.aiLocate`, `.aiTap`, etc.

The query results like `aiBoolean`, `aiQuery`, `aiAssert` will never be cached. 

If the cache is not hit, Midscene will call AI model again and the result in cache file will be updated.

## FAQ

### No cache file is generated

Please ensure you have correctly configured caching:

1. **Direct Agent creation**: Set `cache: { id: "your-cache-id" }` in the constructor
2. **Playwright AI Fixture mode**: Set `cache: true` or `cache: { id: "your-cache-id" }` in fixture configuration
3. **YAML script mode**: Set `agent.cache.id` in the YAML file
4. **Read-only mode**: Ensure you called the `agent.flushCache()` method
5. **Legacy approach**: Set `cacheId` and enable `MIDSCENE_CACHE=1` environment variable

### How to check if the cache is hit?

You can view the report file. If the cache is hit, you will see the `cache` tip and the time cost is obviously reduced.

### Why the cache is missed on CI?

You need to commit the cache files to the repository in CI and recheck the cache hit conditions.

### Does it mean that AI services are no longer needed after using cache?

No. Caching is the way to accelerate the execution, but it's not a tool for ensuring long-term script stability. We have noticed many scenarios where the cache may miss when the DOM structure changes. AI services are still needed to reevaluate the task when the cache miss occurs.

### How to manually remove the cache?

You can remove the cache file in the `./midscene_run/cache` directory, or edit the contents in the cache file.

### How to disable the cache for a single API?

You can use the `cacheable` option to disable the cache for a single API.

Please refer to the documentation of the corresponding [API](./api.mdx) for details.

### Limitations of XPath in caching element location

Midscene uses [XPath](https://developer.mozilla.org/en-US/docs/Web/XML/XPath) to cache the element location. ‚Å†We are using a relatively strict strategy to prevent false matches. In these situations, the cache will not be accessed.

1. The text content of the new element at the same XPath is different from the cached element.
2. The DOM structure of the page is changed from the cached one.

When the cache is not hit, the process will fall back to continue using AI services to find the element.

### Get more debug logs for caching

You can set the `DEBUG=midscene:cache:*` environment variable to get more debug logs for caching.
