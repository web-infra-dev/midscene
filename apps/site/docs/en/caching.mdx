# Caching AI planning & locate

Midscene supports caching Plan steps and matched DOM element information to reduce AI model calls and greatly improve execution efficiency.

Android/iOS automation tasks support planning cache but not element location cache (due to lack of XPath support).

**Effect**

With caching enabled, test execution time is significantly reduced. For example, in the following case, execution time was reduced from 51 seconds to 28 seconds.

* **before**

![](/cache/no-cache-time.png)

* **after**

![](/cache/use-cache-time.png)

## Cache files and storage

### Cache principles

Midscene's caching mechanism is based on input stability and output reusability. When the same task instructions are repeatedly executed in similar page environments, Midscene will prioritize using cached results to avoid repeated AI model calls, significantly improving execution efficiency.

The core caching mechanisms include:
- **Task instruction caching**: For planning operations (such as `ai`, `aiAction`), Midscene uses the prompt instruction as the cache key to store the execution plan returned by AI
- **Element location caching**: For location operations (such as `aiLocate`, `aiTap`), the system uses the location prompt as the cache key to store element XPath information, and verifies whether the XPath is still valid on the next execution
- **Invalidation mechanism**: When cache becomes invalid, the system automatically falls back to AI model for re-analysis

### Storage format

Cache contents will be saved in the `./midscene_run/cache` directory with the `.cache.yaml` as the extension name.

These two types of content will be cached:

1. the result of planning, like calls to `.ai` `.aiAction`
2. The XPaths for elements located by AI, such as `.aiLocate`, `.aiTap`, etc.

The query results like `aiBoolean`, `aiQuery`, `aiAssert` will never be cached. 

If the cache is not hit, Midscene will call AI model again and the result in cache file will be updated.

## Cache strategies

### Disable cache

Configuration: `cache: false` or not configuring the `cache` option

Completely disable cache functionality, always call AI model for every operation. Suitable when you need real-time results or for debugging. By default, if you don't configure the `cache` option, caching is disabled.

```javascript
// Direct Agent creation
const agent = new PuppeteerAgent(page, {
  cache: false
});

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);

// YAML configuration
// agent:
//   cache: false
```

### Read-write mode

Configuration: `cache: { id: "my-cache-id" }`

Automatically read existing cache and update cache files during execution. Additionally, the following two scenarios support configuring `cache: true` to auto-generate cache ID:
- Playwright AI Fixture automatically generates cache ID from test information
- YAML mode automatically uses filename as cache ID

```javascript
// Direct Agent creation - explicit cache ID
const agent = new PuppeteerAgent(page, {
  cache: { id: "my-cache-id" }
});

// Playwright AI Fixture - auto-generate cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true  // Auto-generate cache ID from test case name
  }),
);

// Playwright AI Fixture - explicit cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// YAML configuration - explicit cache ID
agent:
  cache:
    id: "my-cache-test"

// YAML configuration - auto-generate cache ID
agent:
  cache: true

```

### Read-only, manual write

Configuration: `cache: { strategy: "read-only", id: "my-cache-id" }`

Only read cache, no automatic writing to cache files. Requires manual `agent.flushCache()` call to write cache files. Suitable for production environments to ensure cache consistency.

```javascript
// Direct Agent creation
const agent = new PuppeteerAgent(page, {
  cache: { strategy: "read-only", id: "my-cache-id" }
});

// Manual cache write required
await agent.flushCache();

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only", id: "readonly-cache" }
  }),
);

// YAML configuration
agent:
  cache:
    id: "my-cache-test"
    strategy: "read-only"
```

### Compatibility mode (not recommended)

Configuration via `MIDSCENE_CACHE=1` environment variable with cacheId, equivalent to read-write mode.

```javascript
// Old way, requires MIDSCENE_CACHE=1 environment variable and cacheId
const agent = new PuppeteerAgent(originPage, {
  cacheId: 'puppeteer-swag-sab'
});
```

```bash
MIDSCENE_CACHE=1 tsx demo.ts
```

## FAQ

### No cache file is generated

Please ensure you have correctly configured caching:

1. **Direct Agent creation**: Set `cache: { id: "your-cache-id" }` in the constructor
2. **Playwright AI Fixture mode**: Set `cache: true` or `cache: { id: "your-cache-id" }` in fixture configuration
3. **YAML script mode**: Set `agent.cache.id` in the YAML file
4. **Read-only mode**: Ensure you called the `agent.flushCache()` method
5. **Legacy approach**: Set `cacheId` and enable `MIDSCENE_CACHE=1` environment variable

### How to check if the cache is hit?

You can view the report file. If the cache is hit, you will see the `cache` tip and the time cost is obviously reduced.

### Why the cache is missed on CI?

You need to commit the cache files to the repository in CI and recheck the cache hit conditions.

### Does it mean that AI services are no longer needed after using cache?

No. Caching is the way to accelerate the execution, but it's not a tool for ensuring long-term script stability. We have noticed many scenarios where the cache may miss when the DOM structure changes. AI services are still needed to reevaluate the task when the cache miss occurs.

### How to manually remove the cache?

You can remove the cache file in the `./midscene_run/cache` directory, or edit the contents in the cache file.

### How to disable the cache for a single API?

You can use the `cacheable` option to disable the cache for a single API.

Please refer to the documentation of the corresponding [API](./api.mdx) for details.

### Limitations of XPath in caching element location

Midscene uses [XPath](https://developer.mozilla.org/en-US/docs/Web/XML/XPath) to cache the element location. ‚Å†We are using a relatively strict strategy to prevent false matches. In these situations, the cache will not be accessed.

1. The text content of the new element at the same XPath is different from the cached element.
2. The DOM structure of the page is changed from the cached one.

When the cache is not hit, the process will fall back to continue using AI services to find the element.

### Get more debug logs for caching

You can set the `DEBUG=midscene:cache:*` environment variable to get more debug logs for caching.
