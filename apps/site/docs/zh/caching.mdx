# 缓存 AI 规划和定位

Midscene 支持缓存 Plan 的步骤与匹配到的元素位置信息，减少 AI 模型的调用次数，从而大幅提升执行效率。

Android/iOS 自动化任务支持 planning 缓存，但不支持元素定位缓存（因为没有 XPath 支持）。

**效果**

通过引入缓存后，用例的执行时间大幅降低了，例如在如下案例中，执行耗时从51秒降低到了28秒。

* **before**

![](/cache/no-cache-time.png)

* **after**

![](/cache/use-cache-time.png)

## 使用方式

想要启用缓存特性，需要在创建 Agent 或配置 YAML 文件时设置 `cache` 选项，缓存配置支持以下模式：

1. **禁用缓存**: `cache: false`
2. **自动 ID 模式**: `cache: true` - 自动从测试信息生成 cache ID（仅 Playwright AI Fixture 支持）
3. **读写模式**: `cache: { id: "my-cache-id" }` - 自动读取和写入缓存
4. **只读模式**: `cache: { strategy: "read-only", id: "my-cache-id" }` - 只读取缓存，需要手动调用 `agent.flushCache()` 写入

这些配置方式在不同的使用模式下都得到支持：
- **Playwright AI Fixture 模式**: 支持自动生成 cache ID 的便捷功能
- **直接创建 Agent 模式**: 需要显式设置 cache ID
- **YAML 脚本模式**: 在配置文件中设置缓存选项

### Playwright AI Fixture（测试集成模式）

使用 Playwright AI Fixture 时，支持自动生成 cache ID，无需手动设置：

```javascript
// 配置 fixture 级别的缓存（自动从测试信息生成 ID）
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true  // 自动从测试用例名称生成 cache ID
  }),
);

// 或者显式设置 cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// 只读模式
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only", id: "readonly-cache" }
  }),
);

// 禁用缓存
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);
```

在测试中使用：

```javascript
test('my test case', async ({ ai, aiAction, agentForPage }) => {
  // 使用 fixture 提供的 AI 方法，缓存配置已自动应用
  await aiAction('click the button');

  // 或者获取 agent 实例
  const agent = await agentForPage();
  await agent.aiAction('click the button');
});
```

**向后兼容（不推荐）**: 仍支持旧的 `cacheId` + `MIDSCENE_CACHE=1` 环境变量方式：

```diff
- playwright test --config=playwright.config.ts
+ MIDSCENE_CACHE=1 playwright test --config=playwright.config.ts
```

### Javascript Agent（直接创建模式）
> 例如 PuppeteerAgent, PlaywrightAgent, iosAgent, androidAgent, AgentOverChromeBridge

直接创建 Agent 实例时，需要显式设置 cache ID：

```javascript
// 读写模式 - 自动读取和写入缓存
const agent = new PuppeteerAgent(originPage, {
  cache: { id: 'puppeteer-swag-sab' }
});

// Playwright Agent 同样支持
const agent = new PlaywrightAgent(page, {
  cache: { id: 'playwright-login-test' }
});

// 只读模式 - 只读取缓存，需要手动写入
const agent = new PuppeteerAgent(originPage, {
  cache: { strategy: "read-only", id: 'puppeteer-swag-sab' }
});

// 手动写入缓存（仅在只读模式下）
await agent.flushCache();

// 禁用缓存
const agent = new PuppeteerAgent(originPage, {
  cache: false
});
```

**向后兼容（不推荐）**: 仍支持旧的方式，需要设置环境变量：

```diff
- tsx demo.ts 
+ MIDSCENE_CACHE=1 tsx demo.ts
```

```javascript
const mid = new PuppeteerAgent(originPage, {
  cacheId: 'puppeteer-swag-sab', // 旧方式，需要 MIDSCENE_CACHE=1
});
```

### Yaml

在 YAML 文件中的 `agent.cache` 配置缓存选项：

**配置方式**：

```yaml
# 读写模式 - 自动读取和写入缓存
target:
  url: https://example.com/
  viewportWidth: 800
  viewportHeight: 600

agent:
  cache:
    id: "my-cache-test"

tasks:
  - name: "测试缓存功能"
    flow:
      - aiAction: "click the title"
```

```yaml
# 只读模式 - 只读取缓存，需要手动写入
agent:
  cache:
    id: "my-cache-test"
    strategy: "read-only"
```

```yaml
# 禁用缓存
agent:
  cache: false
```

**向后兼容（不推荐）**: 仍支持旧的环境变量方式，`cacheId` 会自动设置为 yaml 文件名：

```diff
- npx midscene ./bing-search.yaml
+ # 启用缓存, cacheId 自动设置为 yaml 文件名
+ MIDSCENE_CACHE=1 npx midscene ./bing-search.yaml
```

## 缓存模式

### 读写模式（默认）

```javascript
const agent = new PuppeteerAgent(page, {
  cache: { id: "my-cache-id" }
});
```

- 自动读取已有缓存
- 执行过程中自动更新缓存文件
- 适合开发和调试阶段

### 只读模式

```javascript
const agent = new PuppeteerAgent(page, {
  cache: { strategy: "read-only", id: "my-cache-id" }
});

// 需要手动写入缓存
await agent.flushCache();
```

- 只读取缓存，不自动写入
- 需要手动调用 `flushCache()` 写入缓存
- 适合生产环境，确保缓存的一致性

### 禁用缓存

```javascript
const agent = new PuppeteerAgent(page, {
  cache: false
});
```

- 完全禁用缓存功能
- 每次都重新调用 AI 模型

## 缓存策略

缓存内容会保存到 `./midscene_run/cache` 目录下，以 `.cache.yaml` 为扩展名。

缓存内容分为两类：

1. 任务规划结果，例如 `ai` 和 `aiAction` 方法的结果
2. 元素定位后的 XPath 数据，例如 `.aiLocate`, `.aiTap` 等方法的结果

查询类方法，例如 `aiBoolean`, `aiQuery`, `aiAssert` 的内容不会被缓存。

如果缓存未命中，Midscene 将会重新调用 AI 模型，并更新缓存文件。

## 常见问题

### 没有生成缓存文件

请确认你已正确配置缓存：

1. **直接创建 Agent**: 在构造函数中设置 `cache: { id: "your-cache-id" }`
2. **Playwright AI Fixture 模式**: 在 fixture 配置中设置 `cache: true` 或 `cache: { id: "your-cache-id" }`
3. **YAML 脚本模式**: 在 YAML 文件中设置 `agent.cache.id`
4. **只读模式**: 确保调用了 `agent.flushCache()` 方法
5. **旧方式**: 设置了 `cacheId` 并启用了 `MIDSCENE_CACHE=1` 环境变量

### 如何检查缓存是否命中？

你可以查看报告文件。如果缓存命中，你将看到 `cache` 提示，并且执行时间大幅降低。

### 为什么在 CI 中无法命中缓存？

你需要在 CI 中将缓存文件提交到仓库中，并再次检查缓存命中的条件。

### 如果有了缓存，是否就不需要 AI 服务了？

不是的。

缓存是加速脚本执行的手段，但它不是确保脚本长期稳定执行的工具。我们注意到，当页面发生变化时，缓存可能会失效（例如当元素 DOM 结构发生变化时）。在缓存失效时，Midscene 仍然需要调用 AI 服务来重新执行任务。

### 如何手动删除缓存？

你可以删除 `./midscene_run/cache` 目录中的缓存文件，或者编辑缓存文件的内容。

### 如果我想禁用单个 API 的缓存，怎么办？

你可以使用 `cacheable` 选项来禁用单个 API 的缓存。

具体用法请参考对应 [API](./api.mdx) 的文档。

### 使用 XPath 缓存元素定位信息的局限性

Midscene 使用 [XPath](https://developer.mozilla.org/en-US/docs/Web/XML/XPath) 来缓存元素定位信息。我们使用相对严格的策略来防止误匹配。在以下情况下，缓存不会命中：

1. 新元素在相同的 XPath 下的文本内容与缓存元素不同。
2. 页面的 DOM 结构与缓存时的结构不同。

当缓存未命中时，Midscene 将回退到继续使用 AI 服务来查找元素。

### 获取缓存相关的调试日志

在环境变量中配置 `DEBUG=midscene:cache:*`，你可以看到缓存相关的调试日志。
