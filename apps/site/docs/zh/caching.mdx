# 缓存 AI 规划和定位

Midscene 支持缓存 Plan 的步骤与匹配到的元素位置信息，减少 AI 模型的调用次数，从而大幅提升执行效率。

Android/iOS 自动化任务支持 planning 缓存，但不支持元素定位缓存（因为没有 XPath 支持）。

**效果**

通过引入缓存后，用例的执行时间大幅降低了，例如在如下案例中，执行耗时从51秒降低到了28秒。

* **before**

![](/cache/no-cache-time.png)

* **after**

![](/cache/use-cache-time.png)

## 缓存策略

### 禁用缓存

配置方式：`cache: false` 或不配置 `cache` 选项

完全禁用缓存功能，每次都重新调用 AI 模型。适合需要实时结果或调试时使用。默认情况下，如果不配置 `cache` 选项，缓存是禁用状态。

```javascript
// 直接创建 Agent
const agent = new PuppeteerAgent(page, {
  cache: false
});

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);

// YAML 配置
// agent:
//   cache: false
```

### 读写模式

配置方式：`cache: { id: "my-cache-id" }`

自动读取已有缓存，执行过程中自动更新缓存文件，此外，下面两种场景支持配置 `cache: true` 自动生成 cache ID：
- Playwright AI Fixture 自动从测试信息生成 cache ID
- YAML 模式支持自动使用文件名作为 cache ID

```javascript
// 直接创建 Agent - 显式设置 cache ID
const agent = new PuppeteerAgent(page, {
  cache: { id: "my-cache-id" }
});

// Playwright AI Fixture - 自动生成 cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true  // 自动从测试用例名称生成 cache ID
  }),
);

// Playwright AI Fixture - 显式设置 cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// YAML 配置 - 显式设置 cache ID
agent:
  cache:
    id: "my-cache-test"

// YAML 配置 - 自动生成 cache ID
agent:
  cache: true

```

### 只读，手动写入

配置方式：`cache: { strategy: "read-only", id: "my-cache-id" }`

只读取缓存，不自动写入缓存文件，需要手动调用 `agent.flushCache()` 写入缓存文件，适合生产环境，确保缓存的一致性

```javascript
// 直接创建 Agent
const agent = new PuppeteerAgent(page, {
  cache: { strategy: "read-only", id: "my-cache-id" }
});

// 需要手动写入缓存
await agent.flushCache();

// Playwright AI Fixture
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only"}
  }),
);

// YAML 配置
agent:
  cache:
    strategy: "read-only"
```

### 兼容方式（不推荐）

通过环境变量 `MIDSCENE_CACHE=1` 配合 cacheId 配置，等同于读写模式。

```javascript
// 旧方式，需要 MIDSCENE_CACHE=1 环境变量和 cacheId
const agent = new PuppeteerAgent(originPage, {
  cacheId: 'puppeteer-swag-sab'
});
```

```bash
MIDSCENE_CACHE=1 tsx demo.ts
```

## 在 Playwright 测试场景中使用

使用 Midscene Playwright AI Fixture，Midscene 会自动生成 cacheId，并默认开启读写缓存。

```javascript
// 最简配置：自动生成 cache ID，开启读写缓存
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: true
  }),
);

test('my test case', async ({ ai, aiAction, agentForPage }) => {
  // 使用 fixture 提供的 AI 方法，缓存配置已自动应用
  await aiAction('click the button');

  // 或者获取 agent 实例
  const agent = await agentForPage();
  await agent.aiAction('click the button');
});
```

你也可以手动配置：

```javascript
// 显式设置 cache ID
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { id: "my-fixture-cache" }
  }),
);

// 只读缓存，适合生产环境
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: { strategy: "read-only", id: "readonly-cache" }
  }),
);

// 禁用缓存
export const test = base.extend<PlayWrightAiFixtureType>(
  PlaywrightAiFixture({
    cache: false
  }),
);
```

## 在命令行工具及 Yaml 文件中使用

在 YAML 文件中的 `agent.cache` 配置缓存选项：

```bash
# 读写缓存 - 自动使用文件名作为 cache ID
target:
  url: https://example.com/
  viewportWidth: 800
  viewportHeight: 600

agent:
  cache: true

tasks:
  - name: "测试缓存功能"
    flow:
      - aiAction: "click the title"
```

```bash
# 读写缓存 - 显式设置 cache ID
agent:
  cache:
    id: "my-cache-test"
```

```bash
# 只读缓存 - 只读取缓存，需要手动写入
agent:
  cache:
    id: "my-cache-test"
    strategy: "read-only"
```

```bash
# 禁用缓存
agent:
  cache: false
```

## 在直接创建 Agent 场景中使用

直接创建 Agent 实例时（如 PuppeteerAgent, PlaywrightAgent, iosAgent, androidAgent 等），需要显式设置缓存配置：

```javascript
// 读写缓存 - 自动读取和写入缓存
const agent = new PuppeteerAgent(originPage, {
  cache: { id: 'puppeteer-swag-sab' }
});

// Playwright Agent 同样支持
const agent = new PlaywrightAgent(page, {
  cache: { id: 'playwright-login-test' }
});

// 只读缓存 - 只读取缓存，需要手动写入
const agent = new PuppeteerAgent(originPage, {
  cache: { strategy: "read-only", id: 'puppeteer-swag-sab' }
});

// 手动写入缓存（仅在只读策略下）
await agent.flushCache();

// 禁用缓存
const agent = new PuppeteerAgent(originPage, {
  cache: false
});
```

## 缓存文件和存储

缓存内容会保存到 `./midscene_run/cache` 目录下，以 `.cache.yaml` 为扩展名。

缓存内容分为两类：

1. 任务规划结果，例如 `ai` 和 `aiAction` 方法的结果
2. 元素定位后的 XPath 数据，例如 `.aiLocate`, `.aiTap` 等方法的结果

查询类方法，例如 `aiBoolean`, `aiQuery`, `aiAssert` 的内容不会被缓存。

如果缓存未命中，Midscene 将会重新调用 AI 模型，并更新缓存文件。

## FAQ

### 没有生成缓存文件

请确认你已正确配置缓存：

1. **直接创建 Agent**: 在构造函数中设置 `cache: { id: "your-cache-id" }`
2. **Playwright AI Fixture 模式**: 在 fixture 配置中设置 `cache: true` 或 `cache: { id: "your-cache-id" }`
3. **YAML 脚本模式**: 在 YAML 文件中设置 `agent.cache.id`
4. **只读模式**: 确保调用了 `agent.flushCache()` 方法
5. **旧方式**: 设置了 `cacheId` 并启用了 `MIDSCENE_CACHE=1` 环境变量

### 如何检查缓存是否命中？

你可以查看报告文件。如果缓存命中，你将看到 `cache` 提示，并且执行时间大幅降低。

### 为什么在 CI 中无法命中缓存？

你需要在 CI 中将缓存文件提交到仓库中，并再次检查缓存命中的条件。

### 如果有了缓存，是否就不需要 AI 服务了？

不是的。

缓存是加速脚本执行的手段，但它不是确保脚本长期稳定执行的工具。我们注意到，当页面发生变化时，缓存可能会失效（例如当元素 DOM 结构发生变化时）。在缓存失效时，Midscene 仍然需要调用 AI 服务来重新执行任务。

### 如何手动删除缓存？

你可以删除 `./midscene_run/cache` 目录中的缓存文件，或者编辑缓存文件的内容。

### 如果我想禁用单个 API 的缓存，怎么办？

你可以使用 `cacheable` 选项来禁用单个 API 的缓存。

具体用法请参考对应 [API](./api.mdx) 的文档。

### 使用 XPath 缓存元素定位信息的局限性

Midscene 使用 [XPath](https://developer.mozilla.org/en-US/docs/Web/XML/XPath) 来缓存元素定位信息。我们使用相对严格的策略来防止误匹配。在以下情况下，缓存不会命中：

1. 新元素在相同的 XPath 下的文本内容与缓存元素不同。
2. 页面的 DOM 结构与缓存时的结构不同。

当缓存未命中时，Midscene 将回退到继续使用 AI 服务来查找元素。

### 获取缓存相关的调试日志

在环境变量中配置 `DEBUG=midscene:cache:*`，你可以看到缓存相关的调试日志。
